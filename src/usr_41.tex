\section{Write a Vim script}
\label{Write a Vim script}
The Vim script language is used for the startup vimrc file, syntax files, and many other things.
This chapter explains the items that can be used in a Vim script.
There are a lot of them, thus this is a long chapter.
\localtableofcontentswithrelativedepth{+1}
\subsection{Introduction}
\label{vim-script-intro}
\label{script}
Your first experience with Vim scripts is the vimrc file.
Vim reads it when it starts up and executes the commands.
You can set options to values you prefer.
And you can use any colon command in it (commands that start with a "\verb!:!"; these are sometimes referred to as Ex commands or command-line commands).

Syntax files are also Vim scripts.
As are files that set options for a specific file type.
A complicated macro can be defined by a separate Vim script file.
You can think of other uses yourself.

Let's start with a simple example:

\begin{Verbatim}[samepage=true]
 :let i = 1
 :while i < 5
 :  echo "count is" i
 :  let i += 1
 :endwhile
\end{Verbatim}

\emph{Note}: The "\verb!:!" characters are not really needed here.
You only need to use them when you type a command.
In a Vim script file they can be left out.
We will use them here anyway to make clear these are colon commands and make them stand out from Normal mode commands.
\emph{Note}: You can try out the examples by yanking the lines from the text here and executing them with :@"

The output of the example code is:

\begin{Verbatim}[samepage=true]
    count is 1
    count is 2
    count is 3
    count is 4
\end{Verbatim}

In the first line the "\verb!:let!" command assigns a value to a variable.
The generic form is:

\begin{Verbatim}[samepage=true]
 :let {variable} = {expression}
\end{Verbatim}

In this case the variable name is "\verb!i!" and the expression is a simple value, the number one.

The "\verb!:while!" command starts a loop.
The generic form is:

\begin{Verbatim}[samepage=true]
 :while {condition}
 :  {statements}
 :endwhile
\end{Verbatim}

The statements until the matching "\verb!:endwhile!" are executed for as long as the condition is true.
The condition used here is the expression "\verb!i < 5!".
This is true when the variable i is smaller than five.

\emph{Note}: If you happen to write a while loop that keeps on running, you can interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).

The "\verb!:echo!" command prints its arguments.
In this case the string "count is" and the value of the variable i.
Since i is one, this will print:

\begin{Verbatim}[samepage=true]
    count is 1
\end{Verbatim}

Then there is the "\verb!:let i += 1!" command.
This does the same thing as "\verb!:let i = i + 1!".
This adds one to the variable i and assigns the new value to the same variable.

The example was given to explain the commands, but would you really want to make such a loop it can be written much more compact:

\begin{Verbatim}[samepage=true]
 :for i in range(1, 4)
 :  echo "count is" i
 :endfor
\end{Verbatim}

We won't explain how |:for| and |\verb!:h range()!| work until later.
Follow the links if you are impatient.

\subsubsection{Three kinds of numbers}
Numbers can be decimal, hexadecimal or octal.
A hexadecimal number starts with "\verb!0x!" or "\verb!0X!".
For example "\verb!0x1f!" is decimal 31.
An octal number starts with a zero.
"\verb!017!" is decimal 15.
Careful: don't put a zero before a decimal number, it will be interpreted as an octal number!

The "\verb!:echo!" command always prints decimal numbers.
Example:

\begin{Verbatim}[samepage=true]
 :echo 0x7f 036
    127 30
\end{Verbatim}

A number is made negative with a minus sign.
This also works for hexadecimal and octal numbers.
A minus sign is also used for subtraction.
Compare this with the previous example:

\begin{Verbatim}[samepage=true]
 :echo 0x7f -036
    97
\end{Verbatim}

White space in an expression is ignored.
However, it's recommended to use it for separating items, to make the expression easier to read.
For example, to avoid the confusion with a negative number above, put a space between the minus sign and the following number:

\begin{Verbatim}[samepage=true]
 :echo 0x7f - 036
\end{Verbatim}
\subsection{Variables}
A variable name consists of ASCII letters, digits and the underscore.
It cannot start with a digit.
Valid variable names are:

\begin{Verbatim}[samepage=true]
    counter
    _aap3
    very_long_variable_name_with_underscores
    FuncLength
    LENGTH
\end{Verbatim}

Invalid names are "\verb!foo+bar!" and "\verb!6var!".

These variables are global.
To see a list of currently defined variables use this command:

\begin{Verbatim}[samepage=true]
 :let
\end{Verbatim}

You can use global variables everywhere.
This also means that when the variable "\verb!count!" is used in one script file, it might also be used in another file.
This leads to confusion at least, and real problems at worst.
To avoid this, you can use a variable local to a script file by prepending "\verb!s:!".
For example, one script contains this code:

\begin{Verbatim}[samepage=true]
 :let s:count = 1
 :while s:count < 5
 :  source other.vim
 :  let s:count += 1
 :endwhile
\end{Verbatim}

Since "\verb!s:count!" is local to this script, you can be sure that sourcing the "\verb!other.vim!" script will not change this variable.
If "\verb!other.vim!" also uses an "\verb!s:count!" variable, it will be a different copy, local to that script.
More about script-local variables here: |\verb!:h script-variable!|.

There are more kinds of variables, see |\verb!:h internal-variables!|.
The most often used ones are:

\begin{center} \begin{tabular}{c l}
				\verb!b:name! & variable local to a buffer \\
				\verb!w:name! & variable local to a window \\
				\verb!g:name! & global variable (also in a function) \\
				\verb!v:name! & variable predefined by Vim \\
\end{tabular} \end{center}
\subsubsection{Deleting variables}
Variables take up memory and show up in the output of the "\verb!:let!" command.
To delete a variable use the "\verb!:unlet!" command.
Example:

\begin{Verbatim}[samepage=true]
 :unlet s:count
\end{Verbatim}

This deletes the script-local variable "\verb!s:count!" to free up the memory it uses.
If you are not sure if the variable exists, and don't want an error message when it doesn't, append !:

\begin{Verbatim}[samepage=true]
 :unlet! s:count
\end{Verbatim}

When a script finishes, the local variables used there will not be automatically freed.
The next time the script executes, it can still use the old value.
Example:

\begin{Verbatim}[samepage=true]
 :if !exists("s:call_count")
 :  let s:call_count = 0
 :endif
 :let s:call_count = s:call_count + 1
 :echo "called" s:call_count "times"
\end{Verbatim}

The "\verb!exists()!" function checks if a variable has already been defined.
Its argument is the name of the variable you want to check.
Not the variable itself!  If you would do this:

\begin{Verbatim}[samepage=true]
 :if !exists(s:call_count)
\end{Verbatim}

Then the value of \verb!s:call_count! will be used as the name of the variable that \verb!exists()! checks.
That's not what you want.

The exclamation mark \verb;!; negates a value.
When the value was true, it becomes false.
When it was false, it becomes true.
You can read it as "not".
Thus "\verb;if !exists();" can be read as "\verb!if not exists()!".

What Vim calls true is anything that is not zero.
Zero is false.

\emph{Note}:
Vim automatically converts a string to a number when it is looking for a number.
When using a string that doesn't start with a digit the resulting number is zero.
Thus look out for this:

\begin{Verbatim}[samepage=true]
  :if "true"
\end{Verbatim}

The "\verb!true!" will be interpreted as a zero, thus as false!
\subsubsection{String variables and constants}
So far only numbers were used for the variable value.
Strings can be used as well.
Numbers and strings are the basic types of variables that Vim supports.
The type is dynamic, it is set each time when assigning a value to the variable with "\verb!:let!".
More about types in |\hyperref[Lists and Dictionaries]{\texttt{Lists and Dictionaries}}|.

To assign a string value to a variable, you need to use a string constant.
There are two types of these.
First the string in double quotes:

\begin{Verbatim}[samepage=true]
 :let name = "peter"
 :echo name
    peter
\end{Verbatim}

If you want to include a double quote inside the string, put a backslash in front of it:

\begin{Verbatim}[samepage=true]
 :let name = "\"peter\""
 :echo name
    "peter"
\end{Verbatim}

To avoid the need for a backslash, you can use a string in single quotes:

\begin{Verbatim}[samepage=true]
 :let name = '"peter"'
 :echo name
    "peter"
\end{Verbatim}

Inside a single-quote string all the characters are as they are.
Only the single quote itself is special: you need to use two to get one.
A backslash is taken literally, thus you can't use it to change the meaning of the character after it.

In double-quote strings it is possible to use special characters.
Here are a few useful ones:

\begin{center} \begin{tabular}{c l}
				\verb!\t! & <Tab> \\
				\verb!\n! & <NL>, line break \\
				\verb!\r! & <CR>, <Enter> \\
				\verb!\e! & <Esc> \\
				\verb!\b! & <BS>, backspace \\
				\verb!\"! & " \\
				\verb!\\! & \, backslash \\
				\verb!\<Esc>! & <Esc> \\
				\verb!\<C-W>! & CTRL-W \\
\end{tabular} \end{center}

The last two are just examples.
The  "\verb!\<name>!" form can be used to include the special key "\verb!name!".

See |\verb!:h expr-quote!| for the full list of special items in a string.
\subsection{Expressions}
Vim has a rich, yet simple way to handle expressions.
You can read the definition here: |\verb!:h expression-syntax!|.
Here we will show the most common items.

The numbers, strings and variables mentioned above are expressions by themselves.
Thus everywhere an expression is expected, you can use a number, string or variable.
Other basic items in an expression are:

\begin{center} \begin{tabular}{c l}
				\verb!$NAME! & environment variable \\
				\verb!&name! & option \\
				\verb!@r! & register \\
\end{tabular} \end{center}

Examples:

\begin{Verbatim}[samepage=true]
 :echo "The value of 'tabstop' is" &ts
 :echo "Your home directory is" $HOME
 :if @a > 5
\end{Verbatim}

The \verb!&name! form can be used to save an option value, set it to a new value, do something and restore the old value.
Example:

\begin{Verbatim}[samepage=true]
 :let save_ic = &ic
 :set noic
 :/The Start/,$delete
 :let &ic = save_ic
\end{Verbatim}

This makes sure the "The Start" pattern is used with the 'ignorecase' option off.
Still, it keeps the value that the user had set.
(Another way to do this would be to add "\verb!\C!" to the pattern, see |/\textbackslash C|.)

\subsubsection{Mathematics}
It becomes more interesting if we combine these basic items.
Let's start with mathematics on numbers:

\begin{center} \begin{tabular}{c l}
				\verb!a + b! & add \\
				\verb!a - b! & subtract \\
				\verb!a * b! & multiply \\
				\verb!a / b! & divide \\
				\verb!a % b! & modulo \\
\end{tabular} \end{center}

The usual precedence is used.
Example:

\begin{Verbatim}[samepage=true]
 :echo 10 + 5 * 2
    20
\end{Verbatim}

Grouping is done with parentheses.
No surprises here.
Example:

\begin{Verbatim}[samepage=true]
 :echo (10 + 5) * 2
    30
\end{Verbatim}

Strings can be concatenated with "\verb!.!".
Example:

\begin{Verbatim}[samepage=true]
 :echo "foo" . "bar"
    foobar
\end{Verbatim}

When the "\verb!:echo!" command gets multiple arguments, it separates them with a space.
In the example the argument is a single expression, thus no space is inserted.

Borrowed from the C language is the conditional expression:

\begin{Verbatim}[samepage=true]
    a ? b : c
\end{Verbatim}

If "\verb!a!" evaluates to true "\verb!b!" is used, otherwise "\verb!c!" is used.
Example:

\begin{Verbatim}[samepage=true]
 :let i = 4
 :echo i > 5 ? "i is big" : "i is small"
    i is small
\end{Verbatim}

The three parts of the constructs are always evaluated first, thus you could see it work as:

\begin{Verbatim}[samepage=true]
    (a) ? (b) : (c)
\end{Verbatim}
\subsection{Conditionals}
The "\verb!:if!" commands executes the following statements, until the matching "\verb!:endif!", only when a condition is met.
The generic form is:

\begin{Verbatim}[samepage=true]
    :if {condition}
       {statements}
    :endif
\end{Verbatim}

Only when the expression {condition} evaluates to true (non-zero) will the {statements} be executed.
These must still be valid commands.
If they contain garbage, Vim won't be able to find the "\verb!:endif!".

You can also use "\verb!:else!".
The generic form for this is:

\begin{Verbatim}[samepage=true]
    :if {condition}
       {statements}
    :else
       {statements}
    :endif
\end{Verbatim}

The second {statements} is only executed if the first one isn't.

Finally, there is "\verb!:elseif!":

\begin{Verbatim}[samepage=true]
    :if {condition}
       {statements}
    :elseif {condition}
       {statements}
    :endif
\end{Verbatim}

This works just like using "\verb!:else!" and then "\verb!if!", but without the need for an extra "\verb!:endif!".

A useful example for your vimrc file is checking the 'term' option and doing something depending upon its value:

\begin{Verbatim}[samepage=true]
 :if &term == "xterm"
 :  " Do stuff for xterm
 :elseif &term == "vt100"
 :  " Do stuff for a vt100 terminal
 :else
 :  " Do something for other terminals
 :endif
\end{Verbatim}

\subsubsection{Logic operations}
We already used some of them in the examples.
These are the most often used ones:

\begin{center} \begin{tabular}{c l}
				\verb;a == b; & equal to \\
				\verb;a != b; & not equal to \\
				\verb;a >  b; & greater than \\
				\verb;a >= b; & greater than or equal to \\
				\verb;a <  b; & less than \\
				\verb;a <= b; & less than or equal to \\
\end{tabular} \end{center}

The result is one if the condition is met and zero otherwise.  An example:

\begin{Verbatim}[samepage=true]
 :if v:version >= 700
 :  echo "congratulations"
 :else
 :  echo "you are using an old version, upgrade!"
 :endif
\end{Verbatim}

Here "\verb!v:version!" is a variable defined by Vim, which has the value of the Vim version.
600 is for version 6.0.
Version 6.1 has the value 601.
This is very useful to write a script that works with multiple versions of Vim.
|\verb!:h v:version!|

The logic operators work both for numbers and strings.
When comparing two strings, the mathematical difference is used.
This compares byte values, which may not be right for some languages.

When comparing a string with a number, the string is first converted to a number.
This is a bit tricky, because when a string doesn't look like a number, the number zero is used.
Example:

\begin{Verbatim}[samepage=true]
 :if 0 == "one"
 :  echo "yes"
 :endif
\end{Verbatim}

This will echo "\verb!yes!", because "\verb!one!" doesn't look like a number, thus it is converted to the number zero.

For strings there are two more items:
\begin{center} \begin{tabular}{c l}
				\verb;a =~ b; & matches with \\
				\verb;a !~ b; & does not match with \\
\end{tabular} \end{center}

The left item "\verb!a!" is used as a string.
The right item "\verb!b!" is used as a pattern, like what's used for searching.
Example:

\begin{Verbatim}[samepage=true]
 :if str =~ " "
 :  echo "str contains a space"
 :endif
 :if str !~ '\.$'
 :  echo "str does not end in a full stop"
 :endif
\end{Verbatim}

Notice the use of a single-quote string for the pattern.
This is useful, because backslashes would need to be doubled in a double-quote string and patterns tend to contain many backslashes.

The 'ignorecase' option is used when comparing strings.
When you don't want that, append "\verb!#!" to match case and "\verb!?!" to ignore case.
Thus "\verb!==?!" compares two strings to be equal while ignoring case.
And "\verb:!~#:" checks if a pattern doesn't match, also checking the case of letters.
For the full table see |\verb!:h expr-==!|.
\subsubsection{More looping}
The "\verb!:while!" command was already mentioned.
Two more statements can be used in between the "\verb!:while!" and the "\verb!:endwhile!":

\begin{center} \begin{tabular}{c l}
				\verb!:continue! & Jump back to the start of the while loop; the loop continues. \\
				\verb!:break! & Jump forward to the "\verb!:endwhile!"; the loop is discontinued. \\
\end{tabular} \end{center}

Example:

\begin{Verbatim}[samepage=true]
 :while counter < 40
 :  call do_something()
 :  if skip_flag
 :    continue
 :  endif
 :  if finished_flag
 :    break
 :  endif
 :  sleep 50m
 :endwhile
\end{Verbatim}

The "\verb!:sleep!" command makes Vim take a nap.
The "\verb!50m!" specifies fifty milliseconds.
Another example is "\verb!:sleep 4!", which sleeps for four seconds.

Even more looping can be done with the "\verb!:for!" command, see below in |\hyperref[Lists and Dictionaries]{\texttt{Lists and Dictionaries}}|.
\subsection{Executing an expression}
So far the commands in the script were executed by Vim directly.
The "\verb!:execute!" command allows executing the result of an expression.
This is a very powerful way to build commands and execute them.

An example is to jump to a tag, which is contained in a variable:

\begin{Verbatim}[samepage=true]
 :execute "tag " . tag_name
\end{Verbatim}

The "\verb!.!" is used to concatenate the string "\verb!tag !" with the value of variable "\verb!tag_name!".
Suppose "\verb!tag_name!" has the value "\verb!get_cmd!", then the command that will be executed is:

\begin{Verbatim}[samepage=true]
 :tag get_cmd
\end{Verbatim}

The "\verb!:execute!" command can only execute colon commands.
The "\verb!:normal!" command executes Normal mode commands.
However, its argument is not an expression but the literal command characters.
Example:

\begin{Verbatim}[samepage=true]
 :normal gg=G
\end{Verbatim}

This jumps to the first line and formats all lines with the "\verb!=!" operator.

To make "\verb!:normal!" work with an expression, combine "\verb!:execute!" with it.
Example:

\begin{Verbatim}[samepage=true]
 :execute "normal " . normal_commands
\end{Verbatim}

The variable "\verb!normal_commands!" must contain the Normal mode commands.

Make sure that the argument for "\verb!:normal!" is a complete command.
Otherwise Vim will run into the end of the argument and abort the command.
For example, if you start Insert mode, you must leave Insert mode as well.
This works:

\begin{Verbatim}[samepage=true]
 :execute "normal Inew text \<Esc>"
\end{Verbatim}

This inserts "\verb!new text !" in the current line.
Notice the use of the special key "\verb!\<Esc>!".
This avoids having to enter a real <Esc> character in your script.

If you don't want to execute a string but evaluate it to get its expression value, you can use the \verb!eval()! function:

\begin{Verbatim}[samepage=true]
 :let optname = "path"
 :let optval = eval('&' . optname)
\end{Verbatim}

A "\verb!&!" character is prepended to "\verb!path!", thus the argument to \verb!eval()! is "\verb!&path!".
The result will then be the value of the 'path' option.

The same thing can be done with:

\begin{Verbatim}[samepage=true]
 :exe 'let optval = &' . optname
\end{Verbatim}

\subsection{Using functions}
Vim defines many functions and provides a large amount of functionality that way.
A few examples will be given in this section.
You can find the whole list here: |\verb!:h functions!|.

A function is called with the "\verb!:call!" command.
The parameters are passed in between parentheses separated by commas.
Example:

\begin{Verbatim}[samepage=true]
 :call search("Date: ", "W")
\end{Verbatim}

This calls the \verb!search()! function, with arguments "\verb!Date: !" and "\verb!W!".
The \verb!search()! function uses its first argument as a search pattern and the second one as flags.
The "\verb!W!" flag means the search doesn't wrap around the end of the file.

A function can be called in an expression.
Example:

\begin{Verbatim}[samepage=true]
 :let line = getline(".")
 :let repl = substitute(line, '\a', "*", "g")
 :call setline(".", repl)
\end{Verbatim}

The \verb!getline()! function obtains a line from the current buffer.
Its argument is a specification of the line number.
In this case "\verb!.!" is used, which means the line where the cursor is.

The \verb!substitute()! function does something similar to the "\verb!:substitute!" command.
The first argument is the string on which to perform the substitution.
The second argument is the pattern, the third the replacement string.
Finally, the last arguments are the flags.

The \verb!setline()! function sets the line, specified by the first argument, to a new string, the second argument.
In this example the line under the cursor is replaced with the result of the \verb!substitute().!  Thus the effect of the three statements is equal to:

\begin{Verbatim}[samepage=true]
 :substitute/\a/*/g
\end{Verbatim}

Using the functions becomes more interesting when you do more work before and after the \verb!substitute()! call.

\subsubsection{Functions}
\label{function-list}
There are many functions.
We will mention them here, grouped by what they are used for.
You can find an alphabetical list here: |\verb!:h functions!|.
Use CTRL-] on the function name to jump to detailed help on it.

String manipulation:
\phantomsection
\label{string-functions}
\begin{center} \begin{tabular}{c l}
				\verb!nr2char()! & get a character by its ASCII value \\
				\verb!char2nr()! & get ASCII value of a character \\
				\verb!str2nr()! & convert a string to a Number \\
				\verb!str2float()! & convert a string to a Float \\
				\verb!printf()! & format a string according to \verb!%! items \\
				\verb!escape()! & escape characters in a string with a '\verb!\!' \\
				\verb!shellescape()! & escape a string for use with a shell command \\
				\verb!fnameescape()! & escape a file name for use with a Vim command \\
				\verb!tr()! & translate characters from one set to another \\
				\verb!strtrans()! & translate a string to make it printable \\
				\verb!tolower()! & turn a string to lowercase \\
				\verb!toupper()! & turn a string to uppercase \\
				\verb!match()! & position where a pattern matches in a string \\
				\verb!matchend()! & position where a pattern match ends in a string \\
				\verb!matchstr()! & match of a pattern in a string \\
				\verb!matchlist()! & like \verb!matchstr()! and also return submatches \\
				\verb!stridx()! & first index of a short string in a long string \\
				\verb!strridx()! & last index of a short string in a long string \\
				\verb!strlen()! & length of a string \\
				\verb!substitute()! & substitute a pattern match with a string \\
				\verb!submatch()! & get a specific match in a "\verb!:substitute!" \\
				\verb!strpart()! & get part of a string \\
				\verb!expand()! & expand special keywords \\
				\verb!iconv()! & convert text from one encoding to another \\
				\verb!byteidx()! & byte index of a character in a string \\
				\verb!repeat()! & repeat a string multiple times \\
				\verb!eval()! & evaluate a string expression \\
\end{tabular} \end{center}

List manipulation:
\phantomsection
\label{list-functions}
\begin{center} \begin{tabular}{c l}
				\verb!get()! & get an item without error for wrong index \\
				\verb!len()! & number of items in a List \\
				\verb!empty()! & check if List is empty \\
				\verb!insert()! & insert an item somewhere in a List \\
				\verb!add()! & append an item to a List \\
				\verb!extend()! & append a List to a List \\
				\verb!remove()! & remove one or more items from a List \\
				\verb!copy()! & make a shallow copy of a List \\
				\verb!deepcopy()! & make a full copy of a List \\
				\verb!filter()! & remove selected items from a List \\
				\verb!map()! & change each List item \\
				\verb!sort()! & sort a List \\
				\verb!reverse()! & reverse the order of a List \\
				\verb!split()! & split a String into a List \\
				\verb!join()! & join List items into a String \\
				\verb!range()! & return a List with a sequence of numbers \\
				\verb!string()! & String representation of a List \\
				\verb!call()! & call a function with List as arguments \\
				\verb!index()! & index of a value in a List \\
				\verb!max()! & maximum value in a List \\
				\verb!min()! & minimum value in a List \\
				\verb!count()! & count number of times a value appears in a List \\
				\verb!repeat()! & repeat a List multiple times \\
\end{tabular} \end{center}

Dictionary manipulation:
\phantomsection
\label{dict-functions}
\begin{center} \begin{tabular}{c l}
				\verb!get()! & get an entry without an error for a wrong key \\
				\verb!len()! & number of entries in a Dictionary \\
				\verb!has_key()! & check whether a key appears in a Dictionary \\
				\verb!empty()! & check if Dictionary is empty \\
				\verb!remove()! & remove an entry from a Dictionary \\
				\verb!extend()! & add entries from one Dictionary to another \\
				\verb!filter()! & remove selected entries from a Dictionary \\
				\verb!map()! & change each Dictionary entry \\
				\verb!keys()! & get List of Dictionary keys \\
				\verb!values()! & get List of Dictionary values \\
				\verb!items()! & get List of Dictionary key-value pairs \\
				\verb!copy()! & make a shallow copy of a Dictionary \\
				\verb!deepcopy()! & make a full copy of a Dictionary \\
				\verb!string()! & String representation of a Dictionary \\
				\verb!max()! & maximum value in a Dictionary \\
				\verb!min()! & minimum value in a Dictionary \\
				\verb!count()! & count number of times a value appears \\
\end{tabular} \end{center}

Floating point computation:
\phantomsection
\label{float-functions}
\begin{center} \begin{tabular}{c l}
				\verb!float2nr()! & convert Float to Number \\
				\verb!abs()! & absolute value (also works for Number) \\
				\verb!round()! & round off \\
				\verb!ceil()! & round up \\
				\verb!floor()! & round down \\
				\verb!trunc()! & remove value after decimal point \\
				\verb!log10()! & logarithm to base 10 \\
				\verb!pow()! & value of x to the exponent y \\
				\verb!sqrt()! & square root \\
				\verb!sin()! & sine \\
				\verb!cos()! & cosine \\
				\verb!tan()! & tangent \\
				\verb!asin()! & arc sine \\
				\verb!acos()! & arc cosine \\
				\verb!atan()! & arc tangent \\
				\verb!atan2()! & arc tangent \\
				\verb!sinh()! & hyperbolic sine \\
				\verb!cosh()! & hyperbolic cosine \\
				\verb!tanh()! & hyperbolic tangent \\
\end{tabular} \end{center}

Variables:
\phantomsection
\label{var-functions}
\begin{center} \begin{tabular}{c l}
				\verb!type()! & type of a variable \\
				\verb!islocked()! & check if a variable is locked \\
				\verb!function()! & get a Funcref for a function name \\
				\verb!getbufvar()! & get a variable value from a specific buffer \\
				\verb!setbufvar()! & set a variable in a specific buffer \\
				\verb!getwinvar()! & get a variable from specific window \\
				\verb!gettabvar()! & get a variable from specific tab page \\
				\verb!gettabwinvar()! & get a variable from specific window \& tab page \\
				\verb!setwinvar()! & set a variable in a specific window \\
				\verb!settabvar()! & set a variable in a specific tab page \\
				\verb!settabwinvar()! & set a variable in a specific window \& tab page \\
				\verb!garbagecollect()! & possibly free memory \\
\end{tabular} \end{center}

Cursor and mark position:
\phantomsection
\label{cursor-functions}
\label{mark-functions}
\begin{center} \begin{tabular}{c l}
				\verb!col()! & column number of the cursor or a mark \\
				\verb!virtcol()! & screen column of the cursor or a mark \\
				\verb!line()! & line number of the cursor or mark \\
				\verb!wincol()! & window column number of the cursor \\
				\verb!winline()! & window line number of the cursor \\
				\verb!cursor()! & position the cursor at a line/column \\
				\verb!getpos()! & get position of cursor, mark, etc. \\
				\verb!setpos()! & set position of cursor, mark, etc. \\
				\verb!byte2line()! & get line number at a specific byte count \\
				\verb!line2byte()! & byte count at a specific line \\
				\verb!diff_filler()! & get the number of filler lines above a line \\
\end{tabular} \end{center}

Working with text in the current buffer:
\phantomsection
\label{text-functions}
\begin{center} \begin{tabular}{c l}
				\verb!getline()! & get a line or list of lines from the buffer \\
				\verb!setline()! & replace a line in the buffer \\
				\verb!append()! & append line or list of lines in the buffer \\
				\verb!indent()! & indent of a specific line \\
				\verb!cindent()! & indent according to C indenting \\
				\verb!lispindent()! & indent according to Lisp indenting \\
				\verb!nextnonblank()! & find next non-blank line \\
				\verb!prevnonblank()! & find previous non-blank line \\
				\verb!search()! & find a match for a pattern \\
				\verb!searchpos()! & find a match for a pattern \\
				\verb!searchpair()! & find the other end of a start/skip/end \\
				\verb!searchpairpos()! & find the other end of a start/skip/end \\
				\verb!searchdecl()! & search for the declaration of a name \\
\end{tabular} \end{center}

System functions and manipulation of files:
\phantomsection
\label{system-functions}
\label{file-functions}
\begin{center} \begin{tabular}{c l}
				\verb!glob()! & expand wildcards \\
				\verb!globpath()! & expand wildcards in a number of directories \\
				\verb!findfile()! & find a file in a list of directories \\
				\verb!finddir()! & find a directory in a list of directories \\
				\verb!resolve()! & find out where a shortcut points to \\
				\verb!fnamemodify()! & modify a file name \\
				\verb!pathshorten()! & shorten directory names in a path \\
				\verb!simplify()! & simplify a path without changing its meaning \\
				\verb!executable()! & check if an executable program exists \\
				\verb!filereadable()! & check if a file can be read \\
				\verb!filewritable()! & check if a file can be written to \\
				\verb!getfperm()! & get the permissions of a file \\
				\verb!getftype()! & get the kind of a file \\
				\verb!isdirectory()! & check if a directory exists \\
				\verb!getfsize()! & get the size of a file \\
				\verb!getcwd()! & get the current working directory \\
				\verb!haslocaldir()! & check if current window used |\verb!:h :lcd!| \\
				\verb!tempname()! & get the name of a temporary file \\
				\verb!mkdir()! & create a new directory \\
				\verb!delete()! & delete a file \\
				\verb!rename()! & rename a file \\
				\verb!system()! & get the result of a shell command \\
				\verb!hostname()! & name of the system \\
				\verb!readfile()! & read a file into a List of lines \\
				\verb!writefile()! & write a List of lines into a file \\
\end{tabular} \end{center}

Date and Time:
\phantomsection
\label{date-functions}
\label{time-functions}
\begin{center} \begin{tabular}{c l}
				\verb!getftime()! & get last modification time of a file \\
				\verb!localtime()! & get current time in seconds \\
				\verb!strftime()! & convert time to a string \\
				\verb!reltime()! & get the current or elapsed time accurately \\
				\verb!reltimestr()! & convert reltime() result to a string \\
\end{tabular} \end{center}

Buffers, windows and the argument list:
\phantomsection
\label{buffer-functions}
\label{window-functions}
\label{arg-functions}
\begin{center} \begin{tabular}{c l}
				\verb!argc()! & number of entries in the argument list \\
				\verb!argidx()! & current position in the argument list \\
				\verb!argv()! & get one entry from the argument list \\
				\verb!bufexists()! & check if a buffer exists \\
				\verb!buflisted()! & check if a buffer exists and is listed \\
				\verb!bufloaded()! & check if a buffer exists and is loaded \\
				\verb!bufname()! & get the name of a specific buffer \\
				\verb!bufnr()! & get the buffer number of a specific buffer \\
				\verb!tabpagebuflist()! & return List of buffers in a tab page \\
				\verb!tabpagenr()! & get the number of a tab page \\
				\verb!tabpagewinnr()! & like winnr() for a specified tab page \\
				\verb!winnr()! & get the window number for the current window \\
				\verb!bufwinnr()! & get the window number of a specific buffer \\
				\verb!winbufnr()! & get the buffer number of a specific window \\
				\verb!getbufline()! & get a list of lines from the specified buffer \\
\end{tabular} \end{center}

Command line:
\phantomsection
\label{command-line-functions}
\begin{center} \begin{tabular}{c l}
				\verb!getcmdline()! & get the current command line \\
				\verb!getcmdpos()! & get position of the cursor in the command line \\
				\verb!setcmdpos()! & set position of the cursor in the command line \\
				\verb!getcmdtype()! & return the current command-line type \\
\end{tabular} \end{center}

Quickfix and location lists:
\phantomsection
\label{quickfix-functions}
\begin{center} \begin{tabular}{c l}
				\verb!getqflist()! & list of quickfix errors \\
				\verb!setqflist()! & modify a quickfix list \\
				\verb!getloclist()! & list of location list items \\
				\verb!setloclist()! & modify a location list \\
\end{tabular} \end{center}

Insert mode completion:
\phantomsection
\label{completion-functions}
\begin{center} \begin{tabular}{c l}
				\verb!complete()! & set found matches \\
				\verb!complete_add()! & add to found matches \\
				\verb!complete_check()! & check if completion should be aborted \\
				\verb!pumvisible()! & check if the popup menu is displayed \\
\end{tabular} \end{center}

Folding:
\phantomsection
\label{folding-functions}
\begin{center} \begin{tabular}{c l}
				\verb!foldclosed()! & check for a closed fold at a specific line \\
				\verb!foldclosedend()! & like foldclosed() but return the last line \\
				\verb!foldlevel()! & check for the fold level at a specific line \\
				\verb!foldtext()! & generate the line displayed for a closed fold \\
				\verb!foldtextresult()! & get the text displayed for a closed fold \\
\end{tabular} \end{center}

Syntax and highlighting:
\phantomsection
\label{syntax-functions}
\label{highlighting-functions}
\begin{center} \begin{tabular}{c l}
				\verb!clearmatches()! & clear all matches defined by |matchadd()| and the |\verb!:h :match!| commands \\
				\verb!getmatches()! & get all matches defined by |matchadd()| and the |\verb!:h :match!| commands \\
				\verb!hlexists()! & check if a highlight group exists \\
				\verb!hlID()! & get ID of a highlight group \\
				\verb!synID()! & get syntax ID at a specific position \\
				\verb!synIDattr()! & get a specific attribute of a syntax ID \\
				\verb!synIDtrans()! & get translated syntax ID \\
				\verb!synstack()! & get list of syntax IDs at a specific position \\
				\verb!synconcealed()! & get info about concealing \\
				\verb!diff_hlID()! & get highlight ID for diff mode at a position \\
				\verb!matchadd()! & define a pattern to highlight (a "match") \\
				\verb!matcharg()! & get info about |\verb!:h :match!| arguments \\
				\verb!matchdelete()! & delete a match defined by |matchadd()| or a |\verb!:h :match!| command \\
				\verb!setmatches()! & restore a list of matches saved by |\verb!:h getmatches()!| \\
\end{tabular} \end{center}

Spelling:
\phantomsection
\label{spell-functions}
\begin{center} \begin{tabular}{c l}
				\verb!spellbadword()! & locate badly spelled word at or after cursor \\
				\verb!spellsuggest()! & return suggested spelling corrections \\
				\verb!soundfold()! & return the sound-a-like equivalent of a word \\
\end{tabular} \end{center}

History:
\phantomsection
\label{history-functions}
\begin{center} \begin{tabular}{c l}
				\verb!histadd()! & add an item to a history \\
				\verb!histdel()! & delete an item from a history \\
				\verb!histget()! & get an item from a history \\
				\verb!histnr()! & get highest index of a history list \\
\end{tabular} \end{center}

Interactive:
\phantomsection
\label{interactive-functions}
\begin{center} \begin{tabular}{c l}
				\verb!browse()! & put up a file requester \\
				\verb!browsedir()! & put up a directory requester \\
				\verb!confirm()! & let the user make a choice \\
				\verb!getchar()! & get a character from the user \\
				\verb!getcharmod()! & get modifiers for the last typed character \\
				\verb!feedkeys()! & put characters in the typeahead queue \\
				\verb!input()! & get a line from the user \\
				\verb!inputlist()! & let the user pick an entry from a list \\
				\verb!inputsecret()! & get a line from the user without showing it \\
				\verb!inputdialog()! & get a line from the user in a dialog \\
				\verb!inputsave()! & save and clear typeahead \\
				\verb!inputrestore()! & restore typeahead \\
\end{tabular} \end{center}

\subsubsection{GUI:}
\label{gui-functions}
\begin{center} \begin{tabular}{c l}
				\verb!getfontname()! & get name of current font being used \\
				\verb!getwinposx()! & X position of the GUI Vim window \\
				\verb!getwinposy()! & Y position of the GUI Vim window \\
\end{tabular} \end{center}

Vim server:
\phantomsection
\label{server-functions}
\begin{center} \begin{tabular}{c l}
				\verb!serverlist()! & return the list of server names \\
				\verb!remote_send()! & send command characters to a Vim server \\
				\verb!remote_expr()! & evaluate an expression in a Vim server \\
				\verb!server2client()! & send a reply to a client of a Vim server \\
				\verb!remote_peek()! & check if there is a reply from a Vim server \\
				\verb!remote_read()! & read a reply from a Vim server \\
				\verb!foreground()! & move the Vim window to the foreground \\
				\verb!remote_foreground()! & move the Vim server window to the foreground \\
\end{tabular} \end{center}

Window size and position:
\phantomsection
\label{window-size-functions}
\begin{center} \begin{tabular}{c l}
				\verb!winheight()! & get height of a specific window \\
				\verb!winwidth()! & get width of a specific window \\
				\verb!winrestcmd()! & return command to restore window sizes \\
				\verb!winsaveview()! & get view of current window \\
				\verb!winrestview()! & restore saved view of current window \\
\end{tabular} \end{center}

Various:
\phantomsection
\label{various-functions}
\begin{center} \begin{tabular}{c l}
				\verb!mode()! & get current editing mode \\
				\verb!visualmode()! & last visual mode used \\
				\verb!hasmapto()! & check if a mapping exists \\
				\verb!mapcheck()! & check if a matching mapping exists \\
				\verb!maparg()! & get rhs of a mapping \\
				\verb!exists()! & check if a variable, function, etc. exists \\
				\verb!has()! & check if a feature is supported in Vim \\
				\verb!changenr()! & return number of most recent change \\
				\verb!cscope_connection()! & check if a cscope connection exists \\
				\verb!did_filetype()! & check if a FileType autocommand was used \\
				\verb!eventhandler()! & check if invoked by an event handler \\
				\verb!getpid()! & get process ID of Vim \\
				\verb!libcall()! & call a function in an external library \\
				\verb!libcallnr()! & idem, returning a number \\
				\verb!getreg()! & get contents of a register \\
				\verb!getregtype()! & get type of a register \\
				\verb!setreg()! & set contents and type of a register \\
				\verb!taglist()! & get list of matching tags \\
				\verb!tagfiles()! & get a list of tags files \\
				\verb!mzeval()! & evaluate |\verb!:h MzScheme!| expression \\
\end{tabular} \end{center}
\subsection{Defining a function}
Vim enables you to define your own functions.
The basic function declaration begins as follows:

\begin{Verbatim}[samepage=true]
 :function {name}({var1}, {var2}, ...)
 :  {body}
 :endfunction
\end{Verbatim}

\emph{Note}:
Function names must begin with a capital letter.

Let's define a short function to return the smaller of two numbers.
It starts with this line:

\begin{Verbatim}[samepage=true]
 :function Min(num1, num2)
\end{Verbatim}

This tells Vim that the function is named "\verb!Min!" and it takes two arguments: "\verb!num1!" and "\verb!num2!".

The first thing you need to do is to check to see which number is smaller:

\begin{Verbatim}[samepage=true]
 :  if a:num1 < a:num2
\end{Verbatim}

The special prefix "\verb!a:!" tells Vim that the variable is a function argument.
Let's assign the variable "\verb!smaller!" the value of the smallest number:

\begin{Verbatim}[samepage=true]
 :  if a:num1 < a:num2
 :    let smaller = a:num1
 :  else
 :    let smaller = a:num2
 :  endif
\end{Verbatim}

The variable "\verb!smaller!" is a local variable.
Variables used inside a function are local unless prefixed by something like "\verb!g:!", "\verb!a:!", or "\verb!s:!".

\emph{Note}:
To access a global variable from inside a function you must prepend "\verb!g:!" to it.
Thus "\verb!g:today!" inside a function is used for the global variable "\verb!today!", and "\verb!today!" is another variable, local to the function.

You now use the "\verb!:return!" statement to return the smallest number to the user.
Finally, you end the function:

\begin{Verbatim}[samepage=true]
 :  return smaller
 :endfunction
\end{Verbatim}

The complete function definition is as follows:

\begin{Verbatim}[samepage=true]
 :function Min(num1, num2)
 :  if a:num1 < a:num2
 :    let smaller = a:num1
 :  else
 :    let smaller = a:num2
 :  endif
 :  return smaller
 :endfunction
\end{Verbatim}

For people who like short functions, this does the same thing:

\begin{Verbatim}[samepage=true]
 :function Min(num1, num2)
 :  if a:num1 < a:num2
 :    return a:num1
 :  endif
 :  return a:num2
 :endfunction
\end{Verbatim}

A user defined function is called in exactly the same way as a built-in function.
Only the name is different.
The Min function can be used like this:

\begin{Verbatim}[samepage=true]
 :echo Min(5, 8)
\end{Verbatim}

Only now will the function be executed and the lines be interpreted by Vim.
If there are mistakes, like using an undefined variable or function, you will now get an error message.
When defining the function these errors are not detected.

When a function reaches "\verb!:endfunction!" or "\verb!:return!" is used without an argument, the function returns zero.

To redefine a function that already exists, use the ! for the "\verb!:function!" command:

\begin{Verbatim}[samepage=true]
 :function!  Min(num1, num2, num3)
\end{Verbatim}

\subsubsection{Using a range}
The "\verb!:call!" command can be given a line range.
This can have one of two meanings.
When a function has been defined with the "\verb!range!" keyword, it will take care of the line range itself.
The function will be passed the variables "\verb!a:firstline!" and "\verb!a:lastline!".
These will have the line numbers from the range the function was called with.
Example:

\begin{Verbatim}[samepage=true]
 :function Count_words() range
 :  let lnum = a:firstline
 :  let n = 0
 :  while lnum <= a:lastline
 :    let n = n + len(split(getline(lnum)))
 :    let lnum = lnum + 1
 :  endwhile
 :  echo "found " . n . " words"
 :endfunction
\end{Verbatim}

You can call this function with:

\begin{Verbatim}[samepage=true]
 :10,30call Count_words()
\end{Verbatim}

It will be executed once and echo the number of words.

The other way to use a line range is by defining a function without the "\verb!range!" keyword.
The function will be called once for every line in the range, with the cursor in that line.
Example:

\begin{Verbatim}[samepage=true]
 :function  Number()
 :  echo "line " . line(".") . " contains: " . getline(".")
 :endfunction
\end{Verbatim}

If you call this function with:

\begin{Verbatim}[samepage=true]
 :10,15call Number()
\end{Verbatim}

The function will be called six times.
\subsubsection{Variable number of arguments}
Vim enables you to define functions that have a variable number of arguments.
The following command, for instance, defines a function that must have 1 argument (start) and can have up to 20 additional arguments:

\begin{Verbatim}[samepage=true]
 :function Show(start, ...)
\end{Verbatim}

The variable "\verb!a:1!" contains the first optional argument, "\verb!a:2!" the second, and so on.
The variable "\verb!a:0!" contains the number of extra arguments.

For example:

\begin{Verbatim}[samepage=true]
 :function Show(start, ...)
 :  echohl Title
 :  echo "start is " . a:start
 :  echohl None
 :  let index = 1
 :  while index <= a:0
 :    echo "  Arg " . index . " is " . a:{index}
 :    let index = index + 1
 :  endwhile
 :  echo ""
 :endfunction
\end{Verbatim}

This uses the "\verb!:echohl!" command to specify the highlighting used for the following "\verb!:echo!" command.
"\verb!:echohl None!" stops it again.
The "\verb!:echon!" command works like "\verb!:echo!", but doesn't output a line break.

You can also use the a:000 variable, it is a List of all the "\verb!...!" arguments.
See |\verb!:h a:000!|.

\subsubsection{Listing functions}
The "\verb!:function!" command lists the names and arguments of all user-defined
functions:

\begin{Verbatim}[samepage=true]
 :function
    function Show(start, ...)
    function GetVimIndent()
    function SetSyn(name)
\end{Verbatim}

To see what a function does, use its name as an argument for "\verb!:function!":

\begin{Verbatim}[samepage=true]
 :function SetSyn
    1     if &syntax == ''
    2       let &syntax = a:name
    3     endif
       endfunction
\end{Verbatim}

\subsubsection{Debugging}
The line number is useful for when you get an error message or when debugging.
See |\verb!:h debug-scripts!| about debugging mode.

You can also set the 'verbose' option to 12 or higher to see all function calls.
Set it to 15 or higher to see every executed line.

\subsubsection{Deleting a function}
To delete the \verb!Show()! function:

\begin{Verbatim}[samepage=true]
 :delfunction Show
\end{Verbatim}

You get an error when the function doesn't exist.

\subsubsection{Function references}
Sometimes it can be useful to have a variable point to one function or another.
You can do it with the function() function.
It turns the name of a function into a reference:

\begin{Verbatim}[samepage=true]
 :let result = 0     " or 1
 :function! Right()
 :  return 'Right!'
 :endfunc
 :function! Wrong()
 :  return 'Wrong!'
 :endfunc
 :
 :if result == 1
 :  let Afunc = function('Right')
 :else
 :  let Afunc = function('Wrong')
 :endif
 :echo call(Afunc, [])
    Wrong!
\end{Verbatim}

\emph{Note} that the name of a variable that holds a function reference must start with a capital.
Otherwise it could be confused with the name of a builtin function.

The way to invoke a function that a variable refers to is with the call() function.
Its first argument is the function reference, the second argument is a List with arguments.

Function references are most useful in combination with a Dictionary, as is explained in the next section.
\subsection{Lists and Dictionaries}
\label{Lists and Dictionaries}
So far we have used the basic types String and Number.
Vim also supports two composite types: List and Dictionary.

A List is an ordered sequence of things.
The things can be any kind of value, thus you can make a List of numbers, a List of Lists and even a List of mixed items.
To create a List with three strings:

\begin{Verbatim}[samepage=true]
 :let alist = ['aap', 'mies', 'noot']
\end{Verbatim}

The List items are enclosed in square brackets and separated by commas.
To create an empty List:

\begin{Verbatim}[samepage=true]
 :let alist = []
\end{Verbatim}

You can add items to a List with the \verb!add()! function:

\begin{Verbatim}[samepage=true]
 :let alist = []
 :call add(alist, 'foo')
 :call add(alist, 'bar')
 :echo alist
    ['foo', 'bar']
\end{Verbatim}

List concatenation is done with \verb!+!:

\begin{Verbatim}[samepage=true]
 :echo alist + ['foo', 'bar']
    ['foo', 'bar', 'foo', 'bar']
\end{Verbatim}

Or, if you want to extend a List directly:

\begin{Verbatim}[samepage=true]
 :let alist = ['one']
 :call extend(alist, ['two', 'three'])
 :echo alist
    ['one', 'two', 'three']
\end{Verbatim}

Notice that using \verb!add()! will have a different effect:

\begin{Verbatim}[samepage=true]
 :let alist = ['one']
 :call add(alist, ['two', 'three'])
 :echo alist
    ['one', ['two', 'three']]
\end{Verbatim}

The second argument of \verb!add()! is added as a single item.
\subsubsection{For loop}
One of the nice things you can do with a List is iterate over it:

\begin{Verbatim}[samepage=true]
 :let alist = ['one', 'two', 'three']
 :for n in alist
 :  echo n
 :endfor
    one
    two
    three
\end{Verbatim}

This will loop over each element in List "\verb!alist!", assigning the value to variable "\verb!n!".
The generic form of a for loop is:

\begin{Verbatim}[samepage=true]
 :for {varname} in {listexpression}
 :  {commands}
 :endfor
\end{Verbatim}

To loop a certain number of times you need a List of a specific length.
The \verb!range()! function creates one for you:

\begin{Verbatim}[samepage=true]
 :for a in range(3)
 :  echo a
 :endfor
    0
    1
    2
\end{Verbatim}

Notice that the first item of the List that \verb!range()! produces is zero, thus the last item is one less than the length of the list.

You can also specify the maximum value, the stride and even go backwards:

\begin{Verbatim}[samepage=true]
 :for a in range(8, 4, -2)
 :  echo a
 :endfor
    8
    6
    4
\end{Verbatim}

A more useful example, looping over lines in the buffer:

\begin{Verbatim}[samepage=true]
 :for line in getline(1, 20)
 :  if line =~ "Date: "
 :    echo matchstr(line, 'Date: \zs.*')
 :  endif
 :endfor
\end{Verbatim}

This looks into lines 1 to 20 (inclusive) and echoes any date found in there.
\subsubsection{Dictionaries}
A Dictionary stores key-value pairs.
You can quickly lookup a value if you know the key.
A Dictionary is created with curly braces:

\begin{Verbatim}[samepage=true]
 :let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
\end{Verbatim}

Now you can lookup words by putting the key in square brackets:

\begin{Verbatim}[samepage=true]
 :echo uk2nl['two']
    twee
\end{Verbatim}

The generic form for defining a Dictionary is:

\begin{Verbatim}[samepage=true]
 {<key> : <value>, ...}
\end{Verbatim}

An empty Dictionary is one without any keys:

\begin{Verbatim}[samepage=true]
 {}
\end{Verbatim}

The possibilities with Dictionaries are numerous.
There are various functions for them as well.
For example, you can obtain a list of the keys and loop over them:

\begin{Verbatim}[samepage=true]
 :for key in keys(uk2nl)
 :  echo key
 :endfor
    three
    one
    two
\end{Verbatim}

You will notice the keys are not ordered.
You can sort the list to get a specific order:

\begin{Verbatim}[samepage=true]
 :for key in sort(keys(uk2nl))
 :  echo key
 :endfor
    one
    three
    two
\end{Verbatim}

But you can never get back the order in which items are defined.
For that you need to use a List, it stores items in an ordered sequence.
\subsubsection{Dictionary functions}
The items in a Dictionary can normally be obtained with an index in square brackets:

\begin{Verbatim}[samepage=true]
 :echo uk2nl['one']
    een
\end{Verbatim}

A method that does the same, but without so many punctuation characters:

\begin{Verbatim}[samepage=true]
 :echo uk2nl.one
    een
\end{Verbatim}

This only works for a key that is made of ASCII letters, digits and the underscore.
You can also assign a new value this way:

\begin{Verbatim}[samepage=true]
 :let uk2nl.four = 'vier'
 :echo uk2nl
    {'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'}
\end{Verbatim}

And now for something special: you can directly define a function and store a reference to it in the dictionary:

\begin{Verbatim}[samepage=true]
 :function uk2nl.translate(line) dict
 :  return join(map(split(a:line), 'get(self, v:val, "???")'))
 :endfunction
\end{Verbatim}

Let's first try it out:

\begin{Verbatim}[samepage=true]
 :echo uk2nl.translate('three two five one')
    drie twee ??? een
\end{Verbatim}

The first special thing you notice is the "\verb!dict!" at the end of the "\verb!:function!" line.
This marks the function as being used from a Dictionary.
The "\verb!self!" local variable will then refer to that Dictionary.

Now let's break up the complicated return command:

\begin{Verbatim}[samepage=true]
 split(a:line)
\end{Verbatim}

The \verb!split()! function takes a string, chops it into whitespace separated words and returns a list with these words.
Thus in the example it returns:

\begin{Verbatim}[samepage=true]
 :echo split('three two five one')
    ['three', 'two', 'five', 'one']
\end{Verbatim}

This list is the first argument to the \verb!map()! function.
This will go through the list, evaluating its second argument with "\verb!v:val!" set to the value of each item.
This is a shortcut to using a for loop.
This command:

\begin{Verbatim}[samepage=true]
 :let alist = map(split(a:line), 'get(self, v:val, "???")')
\end{Verbatim}

Is equivalent to:

\begin{Verbatim}[samepage=true]
 :let alist = split(a:line)
 :for idx in range(len(alist))
 :  let alist[idx] = get(self, alist[idx], "???")
 :endfor
\end{Verbatim}

The \verb!get()! function checks if a key is present in a Dictionary.
If it is, then the value is retrieved.
If it isn't, then the default value is returned, in the example it's '\verb!???!'.
This is a convenient way to handle situations where a key may not be present and you don't want an error message.

The \verb!join()! function does the opposite of \verb!split()!: it joins together a list of words, putting a space in between.
This combination of \verb!split()!, \verb!map()! and \verb!join()! is a nice way to filter a line of words in a very compact way.

\subsubsection{Object oriented programming}
Now that you can put both values and functions in a Dictionary, you can actually use a Dictionary like an object.

Above we used a Dictionary for translating Dutch to English.
We might want to do the same for other languages.
Let's first make an object (aka Dictionary) that has the translate function, but no words to translate:

\begin{Verbatim}[samepage=true]
 :let transdict = {}
 :function transdict.translate(line) dict
 :  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
 :endfunction
\end{Verbatim}

It's slightly different from the function above, using '\verb!self.words!' to lookup word translations.
But we don't have a self.words.
Thus you could call this an abstract class.

Now we can instantiate a Dutch translation object:

\begin{Verbatim}[samepage=true]
 :let uk2nl = copy(transdict)
 :let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
 :echo uk2nl.translate('three one')
    drie een
\end{Verbatim}

And a German translator:

\begin{Verbatim}[samepage=true]
 :let uk2de = copy(transdict)
 :let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
 :echo uk2de.translate('three one')
    drei ein
\end{Verbatim}

You see that the copy() function is used to make a copy of the "\verb!transdict!" Dictionary and then the copy is changed to add the words.
The original remains the same, of course.

Now you can go one step further, and use your preferred translator:

\begin{Verbatim}[samepage=true]
 :if $LANG =~ "de"
 :  let trans = uk2de
 :else
 :  let trans = uk2nl
 :endif
 :echo trans.translate('one two three')
    een twee drie
\end{Verbatim}

Here "\verb!trans!" refers to one of the two objects (Dictionaries).
No copy is made.
More about List and Dictionary identity can be found at |list-identity| and |\verb!:h dict-identity!|.

Now you might use a language that isn't supported.
You can overrule the \verb!translate()! function to do nothing:

\begin{Verbatim}[samepage=true]
 :let uk2uk = copy(transdict)
 :function! uk2uk.translate(line)
 :  return a:line
 :endfunction
 :echo uk2uk.translate('three one wladiwostok')
    three one wladiwostok
\end{Verbatim}

Notice that a \verb:!: was used to overwrite the existing function reference.
Now use "\verb!uk2uk!" when no recognized language is found:

\begin{Verbatim}[samepage=true]
 :if $LANG =~ "de"
 :  let trans = uk2de
 :elseif $LANG =~ "nl"
 :  let trans = uk2nl
 :else
 :  let trans = uk2uk
 :endif
 :echo trans.translate('one two three')
    one two three
\end{Verbatim}

For further reading see |Lists| and |\verb!:h Dictionaries!|.
\subsection{Exceptions}
Let's start with an example:

\begin{Verbatim}[samepage=true]
 :try
 :   read ~/templates/pascal.tmpl
 :catch /E484:/
 :   echo "Sorry, the Pascal template file cannot be found."
 :endtry
\end{Verbatim}

The "\verb!:read!" command will fail if the file does not exist.
Instead of generating an error message, this code catches the error and gives the user a nice message.

For the commands in between "\verb!:try!" and "\verb!:endtry!" errors are turned into exceptions.
An exception is a string.
In the case of an error the string contains the error message.
And every error message has a number.
In this case, the error we catch contains "\verb!E484:!".
This number is guaranteed to stay the same (the text may change, e.g., it may be translated).

When the "\verb!:read!" command causes another error, the pattern "\verb!E484:!" will not match in it.
Thus this exception will not be caught and result in the usual error message.

You might be tempted to do this:

\begin{Verbatim}[samepage=true]
 :try
 :   read ~/templates/pascal.tmpl
 :catch
 :   echo "Sorry, the Pascal template file cannot be found."
 :endtry
\end{Verbatim}

This means all errors are caught.
But then you will not see errors that are useful, such as "\verb!E21: Cannot make changes, 'modifiable' is off!".

Another useful mechanism is the "\verb!:finally!" command:

\begin{Verbatim}[samepage=true]
 :let tmp = tempname()
 :try
 :   exe ".,$write " . tmp
 :   exe "!filter " . tmp
 :   .,$delete
 :   exe "$read " . tmp
 :finally
 :   call delete(tmp)
 :endtry
\end{Verbatim}

This filters the lines from the cursor until the end of the file through the "\verb!filter!" command, which takes a file name argument.
No matter if the filtering works, something goes wrong in between "\verb!:try!" and "\verb!:finally!" or the user cancels the filtering by pressing CTRL-C, the "\verb!call delete(tmp)!" is always executed.
This makes sure you don't leave the temporary file behind.

More information about exception handling can be found in the reference manual: |\verb!:h exception-handling!|.
\subsection{Various remarks}
Here is a summary of items that apply to Vim scripts.
They are also mentioned elsewhere, but form a nice checklist.

The end-of-line character depends on the system.
For Unix a single <NL> character is used.
For MS-DOS, Windows, OS/2 and the like, <CR><LF> is used.
This is important when using mappings that end in a <CR>.
See |\verb!:h :source_crnl!|.
\subsubsection{White space}
Blank lines are allowed and ignored.

Leading whitespace characters (blanks and TABs) are always ignored.
The whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in the example below) are reduced to one blank character and plays the role of a separator, the whitespaces after the last (visible) character may or may not be ignored depending on the situation, see below.

For a "\verb!:set!" command involving the "\verb!=!" (equal) sign, such as in:

\begin{Verbatim}[samepage=true]
 :set cpoptions    =aABceFst
\end{Verbatim}

the whitespace immediately before the "\verb!=!" sign is ignored.
But there can be no whitespace after the "\verb!=!" sign!

To include a whitespace character in the value of an option, it must be escaped by a "\verb!\!" (backslash)  as in the following example:

\begin{Verbatim}[samepage=true]
 :set tags=my\ nice\ file
\end{Verbatim}

The same example written as:

\begin{Verbatim}[samepage=true]
 :set tags=my nice file
\end{Verbatim}

will issue an error, because it is interpreted as:

\begin{Verbatim}[samepage=true]
 :set tags=my
 :set nice
 :set file
\end{Verbatim}

\subsubsection{Comments}
The character \verb!"! (the double quote mark) starts a comment.
Everything after and including this character until the end-of-line is considered a comment and is ignored, except for commands that don't consider comments, as shown in examples below.
A comment can start on any character position on the line.

There is a little "catch" with comments for some commands.
Examples:

\begin{Verbatim}[samepage=true]
 :abbrev dev development     " shorthand
 :map <F3> o#include       " insert include
 :execute cmd            " do it
 :!ls *.c            " list C files
\end{Verbatim}

The abbreviation 'dev' will be expanded to '\verb!development     " shorthand!'.
The mapping of <F3> will actually be the whole line after the '\verb!o# ....!' including the '\verb!" insert include!'.
The "\verb!execute!" command will give an error.
The "\verb:!:" command will send everything after it to the shell, causing an error for an unmatched '\verb!"!' character.

There can be no comment after "\verb!:map!", "\verb!:abbreviate!", "\verb!:execute!" and "\verb:!:" commands (there are a few more commands with this restriction).
For the "\verb!:map!", "\verb!:abbreviate!" and "\verb!:execute!" commands there is a trick:

\begin{Verbatim}[samepage=true]
 :abbrev dev development|" shorthand
 :map <F3> o#include|" insert include
 :execute cmd            |" do it
\end{Verbatim}

With the '\verb!|!' character the command is separated from the next one.
And that next command is only a comment.
For the last command you need to do two things: |\verb!:execute!| and use '\verb!|!':

\begin{Verbatim}[samepage=true]
 :exe '!ls *.c'          |" list C files
\end{Verbatim}

Notice that there is no white space before the '\verb!|!' in the abbreviation and mapping.
For these commands, any character until the end-of-line or '\verb!|!' is included.
As a consequence of this behavior, you don't always see that trailing whitespace is included:

\begin{Verbatim}[samepage=true]
 :map <F4> o#include
\end{Verbatim}

To spot these problems, you can set the 'list' option when editing vimrc files.

For Unix there is one special way to comment a line, that allows making a Vim script executable:

\begin{Verbatim}[samepage=true]
 #!/usr/bin/env vim -S
 echo "this is a Vim script"
 quit
\end{Verbatim}

The "\verb!#!" command by itself lists a line with the line number.
Adding an exclamation mark changes it into doing nothing, so that you can add the shell command to execute the rest of the file. |:\verb0#!0| |\verb!-S!|

\subsubsection{Pitfalls}
Even bigger problem arises in the following example:

\begin{Verbatim}[samepage=true]
 :map ,ab o#include
 :unmap ,ab
\end{Verbatim}

Here the unmap command will not work, because it tries to unmap "\verb!,ab !".
This does not exist as a mapped sequence.
An error will be issued, which is very hard to identify, because the ending whitespace character in "\verb!:unmap ,ab !" is not visible.

And this is the same as what happens when one uses a comment after an '\verb!unmap!' command:

\begin{Verbatim}[samepage=true]
 :unmap ,ab     " comment
\end{Verbatim}

Here the comment part will be ignored.
However, Vim will try to unmap '\verb!,ab     '!', which does not exist.
Rewrite it as:

\begin{Verbatim}[samepage=true]
 :unmap ,ab|    " comment
\end{Verbatim}

\subsubsection{Restoring the view}
Sometimes you want to make a change and go back to where cursor was.
Restoring the relative position would also be nice, so that the same line appears at the top of the window.

This example yanks the current line, puts it above the first line in the file and then restores the view:

\begin{Verbatim}[samepage=true]
 map ,p ma"aYHmbgg"aP`bzt`a
\end{Verbatim}

What this does:\\
\verb!ma"aYHmbgg"aP`bzt`a!
\begin{center} \begin{tabular}{c l}
\verb!ma                 ! & set mark a at cursor position \\
\verb!  "aY              ! & yank current line into register a \\
\verb!     Hmb           ! & go to top line in window and set mark b there \\
\verb!        gg         ! & go to first line in file \\
\verb!          "aP      ! & put the yanked line above it \\
\verb!             `b    ! & go back to top line in display \\
\verb!               zt  ! & position the text in the window as before \\
\verb!                 `a! & go back to saved cursor position \\
\end{tabular} \end{center}

\subsubsection{Packaging}
To avoid your function names to interfere with functions that you get from others, use this scheme:
\begin{itemize} 
				\item Prepend a unique string before each function name.
								I often use an abbreviation.
								For example, "\verb!OW_!" is used for the option window functions.
				\item Put the definition of your functions together in a file.
								Set a global variable to indicate that the functions have been loaded.
								When sourcing the file again, first unload the functions.
\end{itemize}

Example:

\begin{Verbatim}[samepage=true]
 " This is the XXX package

 if exists("XXX_loaded")
   delfun XXX_one
   delfun XXX_two
 endif

 function XXX_one(a)
     ... body of function ...
 endfun

 function XXX_two(b)
     ... body of function ...
 endfun

 let XXX_loaded = 1
\end{Verbatim}
\subsection{Writing a plugin}
\label{Writing a plugin}
\label{write-plugin}
You can write a Vim script in such a way that many people can use it.
This is called a plugin.
Vim users can drop your script in their plugin directory and use its features right away \hyperref[add-plugin]{|\texttt{add-plugin}|}.

There are actually two types of plugins:
\begin{itemize}
				\item global plugins: For all types of files.
				\item filetype plugins: Only for files of a specific type.
\end{itemize}

In this section the first type is explained.
Most items are also relevant for writing filetype plugins.
The specifics for filetype plugins are in the next section \hyperref[write-filetype-plugin]{|\texttt{write-filetype-plugin}|}.

\subsubsection{Name}
First of all you must choose a name for your plugin.
The features provided by the plugin should be clear from its name.
And it should be unlikely that someone else writes a plugin with the same name but which does something different.
And please limit the name to 8 characters, to avoid problems on old Windows systems.

A script that corrects typing mistakes could be called "\verb!typecorr.vim!".
We will use it here as an example.

For the plugin to work for everybody, it should follow a few guidelines.
This will be explained step-by-step.
The complete example plugin is at the end.

\subsubsection{Body}
Let's start with the body of the plugin, the lines that do the actual work:

\begin{Verbatim}[samepage=true]
 14  iabbrev teh the
 15  iabbrev otehr other
 16  iabbrev wnat want
 17  iabbrev synchronisation
 18      \ synchronization
 19  let s:count = 4
\end{Verbatim}

The actual list should be much longer, of course.

The line numbers have only been added to explain a few things, don't put them in your plugin file!
\subsubsection{Header}
You will probably add new corrections to the plugin and soon have several versions laying around.
And when distributing this file, people will want to know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin:

\begin{Verbatim}[samepage=true]
  1  " Vim global plugin for correcting typing mistakes
  2  " Last Change:  2000 Oct 15
  3  " Maintainer:   Bram Moolenaar <Bram@vim.org>
\end{Verbatim}

About copyright and licensing: Since plugins are very useful and it's hardly worth restricting their distribution, please consider making your plugin either public domain or use the Vim |\verb!:h license!|.
A short note about this near the top of the plugin should be sufficient.
Example:

\begin{Verbatim}[samepage=true]
  4  " License:  This file is placed in the public domain.
\end{Verbatim}

\subsubsection{Line continuation, avoiding side effects}
\label{use-cpo-save}

In line 18 above, the line-continuation mechanism is used |\verb!:h line-continuation!|.
Users with 'compatible' set will run into trouble here, they will get an error message.
We can't just reset 'compatible', because that has a lot of side effects.
To avoid this, we will set the 'cpoptions' option to its Vim default value and restore it later.
That will allow the use of line-continuation and make the script work for most people.
It is done like this:

\begin{Verbatim}[samepage=true]
 11  let s:save_cpo = &cpo
 12  set cpo&vim
 ..
 42  let &cpo = s:save_cpo
\end{Verbatim}

We first store the old value of 'cpoptions' in the \verb!s:save_cpo! variable.
At the end of the plugin this value is restored.

Notice that a script-local variable is used |\verb!:h s:var!|.
A global variable could already be in use for something else.
Always use script-local variables for things that are only used in the script.

\subsubsection{Not loading}
It's possible that a user doesn't always want to load this plugin.
Or the system administrator has dropped it in the system-wide plugin directory, but a user has his own plugin he wants to use.
Then the user must have a chance to disable loading this specific plugin.
This will make it possible:

\begin{Verbatim}[samepage=true]
  6  if exists("g:loaded_typecorr")
  7    finish
  8  endif
  9  let g:loaded_typecorr = 1
\end{Verbatim}

This also avoids that when the script is loaded twice it would cause error messages for redefining functions and cause trouble for autocommands that are added twice.

The name is recommended to start with "\verb!loaded_!" and then the file name of the plugin, literally.
The "\verb!g:!" is prepended just to avoid mistakes when using the variable in a function (without "\verb!g:!" it would be a variable local to the function).

Using "\verb!finish!" stops Vim from reading the rest of the file, it's much quicker than using if-endif around the whole file.

\subsubsection{Mapping}
Now let's make the plugin more interesting: We will add a mapping that adds a correction for the word under the cursor.
We could just pick a key sequence for this mapping, but the user might already use it for something else.
To allow the user to define which keys a mapping in a plugin uses, the <Leader> item can be used:

\begin{Verbatim}[samepage=true]
 22    map <unique> <Leader>a  <Plug>TypecorrAdd
\end{Verbatim}

The "\verb!<Plug>TypecorrAdd!" thing will do the work, more about that further on.

The user can set the "\verb!mapleader!" variable to the key sequence that he wants this mapping to start with.
Thus if the user has done:

\begin{Verbatim}[samepage=true]
 let mapleader = "_"
\end{Verbatim}

The mapping will define "\verb!_a!".
If the user didn't do this, the default value will be used, which is a backslash.
Then a map for "\verb!\a!" will be defined.

\emph{Note} that <unique> is used, this will cause an error message if the mapping already happened to exist. |\verb!:h :map-<unique>!|

But what if the user wants to define his own key sequence?
We can allow that with this mechanism:

\begin{Verbatim}[samepage=true]
 21  if !hasmapto('<Plug>TypecorrAdd')
 22    map <unique> <Leader>a  <Plug>TypecorrAdd
 23  endif
\end{Verbatim}

This checks if a mapping to "\verb!<Plug>TypecorrAdd!" already exists, and only defines the mapping from "\verb!<Leader>a!" if it doesn't.
The user then has a chance of putting this in his vimrc file:

\begin{Verbatim}[samepage=true]
 map ,c  <Plug>TypecorrAdd
\end{Verbatim}

Then the mapped key sequence will be "\verb!,c!" instead of "\verb!_a!" or "\verb!\a!".
\subsubsection{Pieces}
If a script gets longer, you often want to break up the work in pieces.
You can use functions or mappings for this.
But you don't want these functions and mappings to interfere with the ones from other scripts.
For example, you could define a function Add(), but another script could try to define the same function.
To avoid this, we define the function local to the script by prepending it with "\verb!s:!".

We will define a function that adds a new typing correction:

\begin{Verbatim}[samepage=true]
 30  function s:Add(from, correct)
 31    let to = input("type the correction for " . a:from . ": ")
 32    exe ":iabbrev " . a:from . " " . to
 ..
 36  endfunction
\end{Verbatim}

Now we can call the function \verb!s:Add()! from within this script.
If another script also defines \verb!s:Add()!, it will be local to that script and can only be called from the script it was defined in.
There can also be a global \verb!Add()!  function (without the "\verb!s:!"), which is again another function.

<SID> can be used with mappings.
It generates a script ID, which identifies the current script.
In our typing correction plugin we use it like this:

\begin{Verbatim}[samepage=true]
 24  noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28  noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
\end{Verbatim}

Thus when a user types "\verb!\a!", this sequence is invoked:

\begin{Verbatim}[samepage=true]
 \a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()
\end{Verbatim}

If another script would also map <SID>Add, it would get another script ID and thus define another mapping.

\emph{Note} that instead of \verb!s:Add()! we use \verb!<SID>Add()! here.
That is because the mapping is typed by the user, thus outside of the script.
The <SID> is translated to the script ID, so that Vim knows in which script to look for the \verb!Add()! function.

This is a bit complicated, but it's required for the plugin to work together with other plugins.
The basic rule is that you use \verb!<SID>Add()! in mappings and \verb!s:Add()! in other places (the script itself, autocommands, user commands).

We can also add a menu entry to do the same as the mapping:

\begin{Verbatim}[samepage=true]
 26  noremenu <script> Plugin.Add\ Correction      <SID>Add
\end{Verbatim}

The "\verb!Plugin!" menu is recommended for adding menu items for plugins.
In this case only one item is used.
When adding more items, creating a submenu is recommended.
For example, "\verb!Plugin.CVS!" could be used for a plugin that offers CVS operations "\verb!Plugin.CVS.checkin!", "\verb!Plugin.CVS.checkout!", etc.

\emph{Note} that in line 28 "\verb!:noremap!" is used to avoid that any other mappings cause trouble.
Someone may have remapped "\verb!:call!", for example.
In line 24 we also use "\verb!:noremap!", but we do want "\verb!<SID>Add!" to be remapped.
This is why "\verb!<script>!" is used here.
This only allows mappings which are local to the script. |\verb!:h :map-<script>!|
The same is done in line 26 for "\verb!:noremenu!".
|\verb!:h :menu-<script>!|

\subsubsection{<SID> and <Plug>}
\label{using-<Plug>}
Both <SID> and <Plug> are used to avoid that mappings of typed keys interfere with mappings that are only to be used from other mappings.
Note the difference between using <SID> and <Plug>:

\begin{description}
				\item [<Plug>]    is visible outside of the script.
								It is used for mappings which the user might want to map a key sequence to.
								<Plug> is a special code that a typed key will never produce.
								To make it very unlikely that other plugins use the same sequence of characters, use this structure: <Plug> scriptname mapname In our example the scriptname is "\verb!Typecorr!" and the mapname is "\verb!Add!".
								This results in "\verb!<Plug>TypecorrAdd!".
								Only the first character of scriptname and mapname is uppercase, so that we can see where mapname starts.

				\item [<SID>]  is the script ID, a unique identifier for a script.
								Internally Vim translates <SID> to "\verb!<SNR>123_!", where "\verb!123!" can be any number.
								Thus a function "\verb!<SID>Add()!" will have a name "\verb!<SNR>11_Add()!" in one script, and "\verb!<SNR>22_Add()!" in another.
								You can see this if you use the "\verb!:function!" command to get a list of functions.
								The translation of <SID> in mappings is exactly the same, that's how you can call a script-local function from a mapping.
\end{description}


\subsubsection{User command}
Now let's add a user command to add a correction:

\begin{Verbatim}[samepage=true]
 38  if !exists(":Correct")
 39    command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40  endif
\end{Verbatim}

The user command is defined only if no command with the same name already exists.
Otherwise we would get an error here.
Overriding the existing user command with "\verb!:command!!" is not a good idea, this would probably make the user wonder why the command he defined himself doesn't work.
|\verb!:h :command!|

\subsubsection{Script variables}
When a variable starts with "\verb!s:!" it is a script variable.
It can only be used inside a script.
Outside the script it's not visible.
This avoids trouble with using the same variable name in different scripts.
The variables will be kept as long as Vim is running.
And the same variables are used when sourcing the same script again. |\verb!:h s:var!|

The fun is that these variables can also be used in functions, autocommands and user commands that are defined in the script.
In our example we can add a few lines to count the number of corrections:

\begin{Verbatim}[samepage=true]
 19  let s:count = 4
 ..
 30  function s:Add(from, correct)
 ..
 34    let s:count = s:count + 1
 35    echo s:count . " corrections now"
 36  endfunction
\end{Verbatim}

First \verb!s:count! is initialized to 4 in the script itself.
When later the \verb!s:Add()! function is called, it increments \verb!s:count!.
It doesn't matter from where the function was called, since it has been defined in the script, it will use the local variables from this script.

\subsubsection{The result}
Here is the resulting complete example:

\begin{Verbatim}[samepage=true]
  1  " Vim global plugin for correcting typing mistakes
  2  " Last Change:  2000 Oct 15
  3  " Maintainer:   Bram Moolenaar <Bram@vim.org>
  4  " License:  This file is placed in the public domain.
  5
  6  if exists("g:loaded_typecorr")
  7    finish
  8  endif
  9  let g:loaded_typecorr = 1
 10
 11  let s:save_cpo = &cpo
 12  set cpo&vim
 13
 14  iabbrev teh the
 15  iabbrev otehr other
 16  iabbrev wnat want
 17  iabbrev synchronisation
 18      \ synchronization
 19  let s:count = 4
 20
 21  if !hasmapto('<Plug>TypecorrAdd')
 22    map <unique> <Leader>a  <Plug>TypecorrAdd
 23  endif
 24  noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26  noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28  noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30  function s:Add(from, correct)
 31    let to = input("type the correction for " . a:from . ": ")
 32    exe ":iabbrev " . a:from . " " . to
 33    if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34    let s:count = s:count + 1
 35    echo s:count . " corrections now"
 36  endfunction
 37
 38  if !exists(":Correct")
 39    command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40  endif
 41
 42  let &cpo = s:save_cpo
\end{Verbatim}

Line 33 wasn't explained yet.
It applies the new correction to the word under the cursor.
The |\verb!:h :normal!| command is used to use the new abbreviation.
Note that mappings and abbreviations are expanded here, even though the function was called from a mapping defined with "\verb!:noremap!".

Using "\verb!unix!" for the 'fileformat' option is recommended.
The Vim scripts will then work everywhere.
Scripts with 'fileformat' set to "\verb!dos!" do not work on Unix.
Also see |\verb!:h :source_crnl!|.
To be sure it is set right, do this before writing the file:

\begin{Verbatim}[samepage=true]
 :set fileformat=unix
\end{Verbatim}

\subsubsection{Documentation}
\label{write-local-help}
It's a good idea to also write some documentation for your plugin.
Especially when its behavior can be changed by the user.
See \hyperref[add-local-help]{|\texttt{add-local-help}|} for how they are installed.

Here is a simple example for a plugin help file, called "\verb!typecorr.txt!":

\begin{Verbatim}[samepage=true]
  1  *typecorr.txt*  Plugin for correcting typing mistakes
  2
  3  If you make typing mistakes, this plugin will have them corrected
  4  automatically.
  5
  6  There are currently only a few corrections.  Add your own if you like.
  7
  8  Mappings:
  9  <Leader>a   or   <Plug>TypecorrAdd
 10      Add a correction for the word under the cursor.
 11
 12  Commands:
 13  :Correct {word}
 14      Add a correction for {word}.
 15
 16                                           *typecorr-settings*
 17  This plugin doesn't have any settings.
\end{Verbatim}

The first line is actually the only one for which the format matters.
It will be extracted from the help file to be put in the "\verb!LOCAL ADDITIONS:!" section of help.txt |\verb!:h local-additions!|.
The first "\verb!*!" must be in the first column of the first line.
After adding your help file do "\verb!:help!" and check that the entries line up nicely.

You can add more tags inside \verb!**! in your help file.
But be careful not to use existing help tags.
You would probably use the name of your plugin in most of them, like "\verb!typecorr-settings!" in the example.

Using references to other parts of the help in \verb!||! is recommended.
This makes it easy for the user to find associated help.
\subsubsection{Filetype detection}
\label{plugin-filetype}
If your filetype is not already detected by Vim, you should create a filetype detection snippet in a separate file.
It is usually in the form of an autocommand that sets the filetype when the file name matches a pattern.
Example:

\begin{Verbatim}[samepage=true]
 au BufNewFile,BufRead *.foo         set filetype=foofoo
\end{Verbatim}

Write this single-line file as "\verb!ftdetect/foofoo.vim!" in the first directory that appears in 'runtimepath'.
For Unix that would be "\verb!~/.vim/ftdetect/foofoo.vim!".
The convention is to use the name of the filetype for the script name.

You can make more complicated checks if you like, for example to inspect the contents of the file to recognize the language.
Also see |\verb!:h new-filetype!|.
\subsubsection{Summary}
\label{plugin-special}

Summary of special things to use in a plugin:
\begin{center} \begin{tabularx}{\textwidth}{c l}
				\texttt{s:name} & Variables local to the script. \\
				\texttt{<SID>} & Script-ID, used for mappings and functions local to the script. \\
				\texttt{hasmapto()} & Function to test if the user already defined a mapping for functionality the script offers. \\
				\texttt{<Leader>} & Value of "\texttt{mapleader}", which the user defines as the keys that plugin mappings start with. \\
				\texttt{:map <unique>} & Give a warning if a mapping already exists. \\
				\texttt{:noremap <script>} & Use only mappings local to the script, not global mappings. \\
				\texttt{exists(":Cmd")} & Check if a user command already exists. \\
\end{tabularx} \end{center}
\subsection{Writing a filetype plugin}
\label{write-filetype-plugin}
\label{ftplugin}
A filetype plugin is like a global plugin, except that it sets options and defines mappings for the current buffer only.
See \hyperref[add-filetype-plugin]{|\texttt{add-filetype-plugin}|} for how this type of plugin is used.

First read the section on global plugins above |\hyperref[Writing a plugin]{\texttt{Writing a plugin}}|.
All that is said there also applies to filetype plugins.
There are a few extras, which are explained here.
The essential thing is that a filetype plugin should only have an effect on the current buffer.

\subsubsection{Disabling}
If you are writing a filetype plugin to be used by many people, they need a chance to disable loading it.
Put this at the top of the plugin:

\begin{Verbatim}[samepage=true]
 " Only do this when not done yet for this buffer
 if exists("b:did_ftplugin")
   finish
 endif
 let b:did_ftplugin = 1
\end{Verbatim}

This also needs to be used to avoid that the same plugin is executed twice for the same buffer (happens when using an "\verb!:edit!" command without arguments).

Now users can disable loading the default plugin completely by making a filetype plugin with only this line:

\begin{Verbatim}[samepage=true]
 let b:did_ftplugin = 1
\end{Verbatim}

This does require that the filetype plugin directory comes before \verb!$VIMRUNTIME! in 'runtimepath'!

If you do want to use the default plugin, but overrule one of the settings, you can write the different setting in a script:

\begin{Verbatim}[samepage=true]
 setlocal textwidth=70
\end{Verbatim}

Now write this in the "\verb!after!" directory, so that it gets sourced after the distributed "\verb!vim.vim!" ftplugin |\verb!:h after-directory!|.
For Unix this would be "\verb!~/.vim/after/ftplugin/vim.vim!".
Note that the default plugin will have set "\verb!b:did_ftplugin!", but it is ignored here.

\subsubsection{Options}
To make sure the filetype plugin only affects the current buffer use the

\begin{Verbatim}[samepage=true]
 :setlocal
\end{Verbatim}

command to set options.
And only set options which are local to a buffer (see the help for the option to check that).
When using |\verb!:h :setlocal!| for global options or options local to a window, the value will change for many buffers, and that is not what a filetype plugin should do.

When an option has a value that is a list of flags or items, consider using "\verb!+=!" and "\verb!-=!" to keep the existing value.
Be aware that the user may have changed an option value already.
First resetting to the default value and then changing it is often a good idea.
Example:

\begin{Verbatim}[samepage=true]
 :setlocal formatoptions& formatoptions+=ro
\end{Verbatim}

\subsubsection{Mappings}
To make sure mappings will only work in the current buffer use the

\begin{Verbatim}[samepage=true]
 :map <buffer>
\end{Verbatim}

command.
This needs to be combined with the two-step mapping explained above.
An example of how to define functionality in a filetype plugin:

\begin{Verbatim}[samepage=true]
 if !hasmapto('<Plug>JavaImport')
   map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
 endif
 noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>
\end{Verbatim}

|\verb!:h hasmapto()!| is used to check if the user has already defined a map to \verb!<Plug>JavaImport!.
If not, then the filetype plugin defines the default mapping.
This starts with |\verb!:h <LocalLeader>!|, which allows the user to select the key(s) he wants filetype plugin mappings to start with.
The default is a backslash.
"\verb!<unique>!" is used to give an error message if the mapping already exists or overlaps with an existing mapping.
|\verb!:h :noremap!| is used to avoid that any other mappings that the user has defined interferes.
You might want to use "\verb!:noremap <script>!" to allow remapping mappings defined in this script that start with <SID>.

The user must have a chance to disable the mappings in a filetype plugin, without disabling everything.
Here is an example of how this is done for a plugin for the mail filetype:

\begin{Verbatim}[samepage=true]
 " Add mappings, unless the user didn't want this.
 if !exists("no_plugin_maps") && !exists("no_mail_maps")
   " Quote text by inserting "> "
   if !hasmapto('<Plug>MailQuote')
     vmap <buffer> <LocalLeader>q <Plug>MailQuote
     nmap <buffer> <LocalLeader>q <Plug>MailQuote
   endif
   vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
   nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
 endif
\end{Verbatim}

Two global variables are used:
\begin{center} \begin{tabular}{c l}
				\verb!no_plugin_maps! & disables mappings for all filetype plugins \\
				\verb!no_mail_maps! & disables mappings for a specific filetype \\
\end{tabular} \end{center}

\subsubsection{User commands}
To add a user command for a specific file type, so that it can only be used in one buffer, use the "\verb!-buffer!" argument to |\verb!:h :command!|.
Example:

\begin{Verbatim}[samepage=true]
 :command -buffer  Make  make %:r.s
\end{Verbatim}

\subsubsection{Variables}
A filetype plugin will be sourced for each buffer of the type it's for.
Local script variables |\verb!:h s:var!| will be shared between all invocations.
Use local buffer variables |\verb!:h b:var!| if you want a variable specifically for one buffer.

\subsubsection{Functions}
When defining a function, this only needs to be done once.
But the filetype plugin will be sourced every time a file with this filetype will be opened.
This construct makes sure the function is only defined once:

\begin{Verbatim}[samepage=true]
 :if !exists("*s:Func")
 :  function s:Func(arg)
 :    ...
 :  endfunction
 :endif
\end{Verbatim}

\subsubsection{Undo}
\label{undo_ftplugin}

When the user does ":setfiletype xyz" the effect of the previous filetype should be undone.
Set the \verb!b:undo_ftplugin! variable to the commands that will undo the settings in your filetype plugin.
Example:

\begin{Verbatim}[samepage=true]
 let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
     \ . "| unlet b:match_ignorecase b:match_words b:match_skip"
\end{Verbatim}

Using "\verb!:setlocal!" with "\verb!<!" after the option name resets the option to its global value.
That is mostly the best way to reset the option value.

This does require removing the "\verb!C!" flag from 'cpoptions' to allow line continuation, as mentioned above \hyperref[use-cpo-save]{|\texttt{use-cpo-save}|}.

\subsubsection{File name}
The filetype must be included in the file name \hyperref[ftplugin-name]{|\texttt{ftplugin-name}|}.
Use one of these three forms:

\begin{Verbatim}[samepage=true]
    .../ftplugin/stuff.vim
    .../ftplugin/stuff_foo.vim
    .../ftplugin/stuff/bar.vim
\end{Verbatim}

"\verb!stuff!" is the filetype, "\verb!foo!" and "\verb!bar!" are arbitrary names.

\subsubsection{Summary}
\label{ftplugin-special}
Summary of special things to use in a filetype plugin:

\begin{center} \begin{tabular}{c l}
				\verb!<LocalLeader>! & Value of "\verb!maplocalleader!", which the user defines as the keys that filetype plugin mappings start with. \\
				\verb!:map <buffer>! & Define a mapping local to the buffer. \\
				\verb!:noremap <script>! & Only remap mappings defined in this script that start with <SID>. \\
				\verb!:setlocal! & Set an option for the current buffer only. \\
				\verb!:command -buffer! & Define a user command local to the buffer. \\
				\verb!exists("*s:Func")! & Check if a function was already defined. \\
\end{tabular} \end{center}

Also see \hyperref[plugin-special]{|\texttt{plugin-special}|}, the special things used for all plugins.
\subsection{Writing a compiler plugin}
\label{write-compiler-plugin}
A compiler plugin sets options for use with a specific compiler.
The user can load it with the |\verb!:h :compiler!| command.
The main use is to set the 'errorformat' and 'makeprg' options.

Easiest is to have a look at examples.
This command will edit all the default compiler plugins:

\begin{Verbatim}[samepage=true]
 :next $VIMRUNTIME/compiler/*.vim
\end{Verbatim}

Use |\verb!:h :next!| to go to the next plugin file.

There are two special items about these files.
First is a mechanism to allow a user to overrule or add to the default file.
The default files start with:

\begin{Verbatim}[samepage=true]
 :if exists("current_compiler")
 :  finish
 :endif
 :let current_compiler = "mine"
\end{Verbatim}

When you write a compiler file and put it in your personal runtime directory (e.g., \verb!~/.vim/compiler! for Unix), you set the "\verb!current_compiler!" variable to make the default file skip the settings.
\phantomsection
\label{:CompilerSet}
The second mechanism is to use "\verb!:set!" for "\verb!:compiler!!" and "\verb!:setlocal!" for "\verb!:compiler!".
Vim defines the "\verb!:CompilerSet!" user command for this.
However, older Vim versions don't, thus your plugin should define it then.
This is an example:

\begin{Verbatim}[samepage=true]
  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&       " use the default 'errorformat'
  CompilerSet makeprg=nmake
\end{Verbatim}

When you write a compiler plugin for the Vim distribution or for a system-wide runtime directory, use the mechanism mentioned above.
When "\verb!current_compiler!" was already set by a user plugin nothing will be done.

When you write a compiler plugin to overrule settings from a default plugin, don't check "\verb!current_compiler!".
This plugin is supposed to be loaded last, thus it should be in a directory at the end of 'runtimepath'.
For Unix that could be \verb!~/.vim/after/compiler!.
\subsection{Writing a plugin that loads quickly}
\label{write-plugin-quickload}
A plugin may grow and become quite long.
The startup delay may become noticeable, while you hardly ever use the plugin.
Then it's time for a quickload plugin.

The basic idea is that the plugin is loaded twice.
The first time user commands and mappings are defined that offer the functionality.
The second time the functions that implement the functionality are defined.

It may sound surprising that quickload means loading a script twice.
What we mean is that it loads quickly the first time, postponing the bulk of the script to the second time, which only happens when you actually use it.
When you always use the functionality it actually gets slower!

\emph{Note} that since Vim 7 there is an alternative: use the |\verb! :h autoload!| functionality |\hyperref[Writing library scripts]{\texttt{Writing library scripts}}|.

The following example shows how it's done:

\begin{Verbatim}[samepage=true]
 " Vim global plugin for demonstrating quick loading
 " Last Change:  2005 Feb 25
 " Maintainer:   Bram Moolenaar <Bram@vim.org>
 " License:  This file is placed in the public domain.

 if !exists("s:did_load")
     command -nargs=* BNRead  call BufNetRead(<f-args>)
     map <F19> :call BufNetWrite('something')<CR>

     let s:did_load = 1
     exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
     finish
 endif

 function BufNetRead(...)
     echo 'BufNetRead(' . string(a:000) . ')'
     " read functionality here
 endfunction

 function BufNetWrite(...)
     echo 'BufNetWrite(' . string(a:000) . ')'
     " write functionality here
 endfunction
\end{Verbatim}

When the script is first loaded "\verb!s:did_load!" is not set.
The commands between the "\verb!if!" and "\verb!endif!" will be executed.
This ends in a |\verb!:h :finish!| command, thus the rest of the script is not executed.

The second time the script is loaded "\verb!s:did_load!" exists and the commands after the "\verb!endif!" are executed.
This defines the (possible long) BufNetRead() and BufNetWrite() functions.

If you drop this script in your plugin directory Vim will execute it on startup.
This is the sequence of events that happens:

\begin{enumerate}
				\item The "\verb!BNRead!" command is defined and the <F19> key is mapped when the script is sourced at startup.
								A |\verb!:h FuncUndefined!| autocommand is defined.
								The "\verb!:finish!" command causes the script to terminate early.
				\item The user types the BNRead command or presses the <F19> key.
								The \verb!BufNetRead()! or \verb!BufNetWrite()! function will be called.
				\item Vim can't find the function and triggers the |\verb!:h FuncUndefined!| autocommand event.
								Since the pattern "\verb!BufNet*!" matches the invoked function, the command "\verb!source fname!" will be executed.
								"\verb!fname!" will be equal to the name of the script, no matter where it is located, because it comes from expanding "\verb!<sfile>!" (see |\verb!:h expand()!|).
				\item The script is sourced again, the "\verb!s:did_load!" variable exists and the functions are defined.
\end{enumerate}}

Notice that the functions that are loaded afterwards match the pattern in the |\verb!:h FuncUndefined!| autocommand.
You must make sure that no other plugin defines functions that match this pattern.
\subsection{Writing library scripts}
\label{Writing library scripts}
\label{write-library-script}
Some functionality will be required in several places.
When this becomes more than a few lines you will want to put it in one script and use it from many scripts.
We will call that one script a library script.

Manually loading a library script is possible, so long as you avoid loading it when it's already done.
You can do this with the |\verb!:h exists()!| function.
Example:

\begin{Verbatim}[samepage=true]
 if !exists('*MyLibFunction')
    runtime library/mylibscript.vim
 endif
 call MyLibFunction(arg)
\end{Verbatim}

Here you need to know that \verb!MyLibFunction()! is defined in a script "\verb!library/mylibscript.vim!" in one of the directories in 'runtimepath'.

To make this a bit simpler Vim offers the autoload mechanism.
Then the example looks like this:

\begin{Verbatim}[samepage=true]
 call mylib#myfunction(arg)
\end{Verbatim}

That's a lot simpler, isn't it?
Vim will recognize the function name and when it's not defined search for the script "\verb!autoload/mylib.vim!" in 'runtimepath'.
That script must define the "\verb!mylib#myfunction()!" function.

You can put many other functions in the mylib.vim script, you are free to organize your functions in library scripts.
But you must use function names where the part before the '\verb!#!' matches the script name.
Otherwise Vim would not know what script to load.

If you get really enthusiastic and write lots of library scripts, you may want to use subdirectories.
Example:

\begin{Verbatim}[samepage=true]
 call netlib#ftp#read('somefile')
\end{Verbatim}

For Unix the library script used for this could be:

\begin{Verbatim}[samepage=true]
    ~/.vim/autoload/netlib/ftp.vim
\end{Verbatim}

Where the function is defined like this:

\begin{Verbatim}[samepage=true]
 function netlib#ftp#read(fname)
     "  Read the file fname through ftp
 endfunction
\end{Verbatim}

Notice that the name the function is defined with is exactly the same as the name used for calling the function.
And the part before the last '\verb!#!' exactly matches the subdirectory and script name.

You can use the same mechanism for variables:

\begin{Verbatim}[samepage=true]
 let weekdays = dutch#weekdays
\end{Verbatim}

This will load the script "\verb!autoload/dutch.vim!", which should contain something like:

\begin{Verbatim}[samepage=true]
 let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
     \ 'donderdag', 'vrijdag', 'zaterdag']
\end{Verbatim}

Further reading: |\verb!:h autoload!|.
\subsection{Distributing Vim scripts}
\label{distribute-script}
Vim users will look for scripts on the Vim website:\url{http://www.vim.org}.
If you made something that is useful for others, share it!

Vim scripts can be used on any system.
There might not be a tar or gzip command.
If you want to pack files together and/or compress them the "zip" utility is recommended.

For utmost portability use Vim itself to pack scripts together.
This can be done with the Vimball utility.
See |\verb!:h vimball!|.

It's good if you add a line to allow automatic updating.
See |\verb!:h glvs-plugins!|.
\clearpage
